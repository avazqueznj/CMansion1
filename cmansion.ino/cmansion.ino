
/***********************************************************************
 
    Chato's Mansion
    Copyright (C) 2019  Alejandro Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
  
 
 * Compile
 ./arduino-cli.exe compile -b arduino:avr:leonardo ./cmansion.ino
 arduino-cli.exe upload -p COM4 -b arduino:avr:leonardo cmansion.ino
 
 ***********************************************************************/

#include <Arduboy2.h> 
#include <ArduboyTones.h>
#include "arduboy_util_ale.h"
#include "LinkedList.h"

Arduboy2 arduboy;
Sprites sprites;
ArduboyTones sound(arduboy.audio.enabled);


const byte PROGMEM ghostSprite[] = {
    8, 8, 
    0x00, 0x80, 0xd0, 0xf0, 0xfe, 0xfc, 0x20, 0x00 
};

const byte PROGMEM playerSprite[] = {
    8, 8, 
    0x00, 0x98, 0xe8, 0x3c, 0xfc, 0x8e, 0x00, 0x00
};

const byte PROGMEM background[] = {
    128, 64, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf0, 0x38, 0x08, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xd0, 0x28,
0x14, 0x0a, 0x0d, 0x06, 0x07, 0x18, 0x11, 0xe2, 0xe4, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0e, 0x08, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x10, 0x08, 0x88, 0x84, 0x84, 0xfa, 0x0f, 0x00,
0x00, 0x1e, 0x32, 0x32, 0x18, 0x00, 0x00, 0x81, 0xff, 0x8f, 0x04, 0x08, 0x08, 0x10, 0x10, 0xf0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x1f, 0x08, 0x0e, 0x72, 0xc3, 0x01, 0x00, 0x00, 0x00, 0x00, 0xe0,
0x30, 0x10, 0xf0, 0x10, 0x10, 0x30, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x01, 0xe1, 0xfa, 0x3e, 0x0c,
0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0xc0, 0x78, 0xc0, 0xa0, 0x30, 0x00, 0x00, 0xc0, 0x20, 0x20, 0x60, 0xc0, 0x00, 0xe0,
0x30, 0x10, 0x10, 0xe0, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xc0, 0x40, 0xc0, 0xc0, 0x60, 0x20,
0x70, 0xd0, 0x98, 0x18, 0x10, 0xe0, 0x04, 0x34, 0xe6, 0x83, 0xbe, 0xe0, 0x80, 0x80, 0x80, 0x83,
0x46, 0x78, 0x41, 0x7e, 0x40, 0x7e, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7f, 0xff, 0x80, 0x80,
0x80, 0x84, 0xc4, 0xfc, 0x84, 0x84, 0xf8, 0x18, 0x08, 0x00, 0x80, 0x90, 0x70, 0x20, 0x20, 0xa0,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0x40, 0x40, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x1f, 0x10, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x0f,
0x08, 0x08, 0x00, 0x07, 0x04, 0x04, 0x07, 0x04, 0x04, 0x07, 0x08, 0x08, 0x08, 0x10, 0x10, 0x20,
0x20, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x00, 0x60, 0x21, 0x20, 0x10, 0x1f, 0x08, 0x08, 0x04, 0x07, 0x04, 0x06,
0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x06, 0x07, 0x04,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const byte PROGMEM splashScreen[] = {
    128, 64,     

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xd0, 0x28,
0x14, 0x0a, 0x0d, 0x06, 0x07, 0x18, 0x11, 0xe2, 0xe4, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x10, 0x08, 0x88, 0x84, 0x84, 0xfa, 0x0f, 0x00,
0x00, 0x1e, 0x32, 0x32, 0x18, 0x00, 0x00, 0x81, 0xff, 0x8f, 0x04, 0x08, 0x08, 0x10, 0x10, 0xf0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x1f, 0x08, 0x0e, 0x72, 0xc3, 0x01, 0x00, 0x00, 0x00, 0x00, 0xe0,
0x30, 0x10, 0xf0, 0x10, 0x10, 0x30, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x01, 0xe1, 0xfa, 0x3e, 0x0c,
0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0xc0, 0x78, 0xc0, 0xa0, 0x30, 0x00, 0x00, 0xc0, 0x20, 0x20, 0x60, 0xc0, 0x00, 0xe0,
0x30, 0x10, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xc0, 0x40, 0xc0, 0xc0, 0x60, 0x20,
0x70, 0xd0, 0x98, 0x18, 0x10, 0xe0, 0x04, 0x34, 0xe6, 0x83, 0xbe, 0xe0, 0x80, 0x80, 0x80, 0x83,
0x46, 0x78, 0x41, 0x7e, 0x40, 0x7e, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7f, 0xff, 0x80, 0x80,
0x80, 0x84, 0xc4, 0xfc, 0x84, 0x84, 0xf8, 0x18, 0x08, 0x00, 0x80, 0x90, 0x70, 0x20, 0x20, 0xa0,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0x40, 0x40, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x1f, 0x10, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x0f,
0x08, 0x08, 0x00, 0x07, 0x04, 0x04, 0x04, 0xf0, 0xfc, 0x0e, 0x02, 0x02, 0x02, 0x10, 0x10, 0xa0,
0x20, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x00, 0x60, 0x21, 0x20, 0x10, 0x1f, 0xc8, 0x48, 0x04, 0x07, 0x04, 0x06,
0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x06, 0x07, 0x04,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x84, 0x08, 0x00, 0x00, 0x00, 0x0f,
0x04, 0x02, 0xc2, 0x64, 0xd8, 0x00, 0x00, 0x1c, 0x12, 0x12, 0x0e, 0x04, 0x18, 0x00, 0x04, 0x04,
0x87, 0x9e, 0x82, 0x02, 0x00, 0x0e, 0x11, 0x12, 0x12, 0x0c, 0x01, 0x90, 0x16, 0x1d, 0x09, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x1c, 0xfc, 0xfc, 0xf0, 0xf0, 0xf0, 0xf0, 0x30, 0x70, 0x90, 0x10,
0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x1c, 0x03, 0x01, 0x03, 0x0e, 0x38, 0xe0, 0x80,
0xe0, 0x7f, 0x01, 0x00, 0x00, 0x03, 0x06, 0x38, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
0xc0, 0x00, 0x01, 0x87, 0xfc, 0x18, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0x7c, 0xc4, 0x04, 0x08,
0xf8, 0x80, 0x0e, 0x12, 0x61, 0xc1, 0x80, 0x00, 0x00, 0xf2, 0x07, 0x02, 0x00, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x20, 0x10, 0x18, 0x18, 0x70, 0xc0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x0f, 0xff, 0xc2, 0xc2, 0xc3, 0xc3,
0xc1, 0xc1, 0xc1, 0xc1, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
0x00, 0x07, 0x00, 0x00, 0x08, 0x08, 0x07, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x1e, 0x61, 0x80, 0x80,
0x61, 0x1e, 0x00, 0x00, 0x00, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1e, 0x20, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    
    
};

const uint16_t song1[] PROGMEM = {
  220,1000, 0,250, 440,500, 880,2000,
  TONES_END };

#define EVENT_TYPE 1
#define PLAYER_TYPE 2
#define GHOST_TYPE 3
#define BULLET_TYPE 4
#define GUNCYCLE_TYPE 5

//--------------------------------------------------------------------------------------

class eventClass{
public:    
    int virtual name(){
        return 0;
    };

    int virtual type(){
        return EVENT_TYPE;
    };
    
    void virtual run(){};
    
    bool virtual isDone(){
        return false;
    };
    
    unsigned long virtual dueTime(){
        return 0;
    };    
    
    bool operator == (const eventClass &other){
       if( name() == other.name()  )
         return true;
       else
         return false;
    }    
    
    virtual ~eventClass(){
        
    }
};

int pk = 0;
LinkedList< eventClass* > scheduler;


//------------------------------------------------------------------------

const float PROGMEM radiansPerAngle = 0.01745329252;
class bouncerClass:public eventClass{
public:
    //uses
    int targetName;
    int currentX = 0;
    int currentY = 0;
    int newCurrentX = 0;   
    int newCurrentY = 0;
    int currentAngle = 0;    
    //has 
    bool alive = true;
    unsigned long birthTime = 0;
    unsigned long timeToLive = 0;
    unsigned long targetSpeed = 0;    
    const byte*   spriteMap;
public:
    
    bouncerClass( int nameParam, int xStart, int yStart, int angleStart, const byte* spriteMapParam,
            unsigned long timeToLiveParam, unsigned long targetSpeedParam ):eventClass(){
        //uses
        currentX = xStart;
        currentY = yStart;
        currentAngle = angleStart;                  
        targetName = nameParam;
        timeToLive = timeToLiveParam;
        targetSpeed = targetSpeedParam;
        spriteMap = spriteMapParam;
        
        //has
        birthTime = millis();
    }
    
    void virtual bouceHorizontally(){
        if( currentAngle < 180 ){
            int dif = currentAngle - 90;
            currentAngle = 90 - dif;
        }else{
            int dif = 270 - currentAngle;
            currentAngle = 270 + dif;
            }          
    }
    
    void virtual bounceVertically(){
        if( currentAngle < 90 ){
            int dif = 90 - currentAngle;
            currentAngle = 270 + dif;
        }else{
            int dif = currentAngle - 90;
            currentAngle = 270 - dif;
        }        
    }
    
    void virtual render(){                
                                                              
        // bounce side left
        if( currentX < 0 || currentX >128 ){            
            bouceHorizontally();
        }
            
        // bounce top & bottom
        if( currentY < 0 || currentY >64 ){
            bounceVertically();            
        }
                
        float angleRadians = currentAngle * radiansPerAngle;                                  
        
        // x component        
        newCurrentX = roundf( currentX + (targetSpeed * cos(angleRadians)));   
        newCurrentY = roundf( currentY - (targetSpeed * sin(angleRadians)));                       
 
        // draw player
        paint();        
        
        currentX = newCurrentX;
        currentY = newCurrentY;   
                
    }
    
    void virtual paint(){
        // draw player
        sprites.drawOverwrite( currentX, currentY, spriteMap, 0);         
    }
            
    int virtual name(){
        return targetName;
    };
    void virtual run(){
        render();
    }    
    bool virtual isDone(){
        return ( millis() > ( birthTime + timeToLive ) );
    }
    unsigned long virtual dueTime(){
        return 0;
    }    
    
    void virtual collision(eventClass * collisionSource){        
    }    
    
    virtual ~bouncerClass(){
    }
    
    
}; 

//--------------------------------------------------------------------------------------

#define BULLET_LIFE 5000
#define BULLET_SPEED 3
class bulletClass:public bouncerClass{
public:
    
    bulletClass( int nameParam, int xStart, int yStart, int angleStart )
        :bouncerClass(  nameParam,  xStart,  yStart,  angleStart, NULL, BULLET_LIFE, BULLET_SPEED ){ }
      
    void virtual paint(){
        arduboy.drawLine(currentX,currentY,newCurrentX,newCurrentY);
    }
    
    int virtual type(){
        return BULLET_TYPE;
    };        
    
    bool hit = false;
    void doHit(){
        hit = true;
    }
    
    bool virtual isDone(){
        if(!hit){
            return bouncerClass::isDone();
        }else{
            return true;
        }
    }
    
    virtual ~bulletClass(){
    }
}; 

//--------------------------------------------------------------------------------------

bool gunCycling = false;
class gunCycleClass:public eventClass{
private:
    //uses
    int gunCycleName;
    unsigned long birthTime = 0;
    unsigned long cycleTime = 0;
public:
    
    gunCycleClass( int nameParam, int timeToCycleParam):eventClass(){
        //uses               
        gunCycleName = nameParam;
        cycleTime = timeToCycleParam;
        //has
        birthTime = millis();
        gunCycling = true;
    }        
            
    int virtual name(){
        return gunCycleName;
    };
    void virtual run(){
        
    }    
    bool virtual isDone(){
        
        if( millis() > ( birthTime + cycleTime ) ){
            gunCycling = false;
            return true;
        }else{
            return false;
        }
            
    }
    
    int virtual type(){
        return GUNCYCLE_TYPE;
    };        
        
    unsigned long virtual dueTime(){
        return  birthTime + cycleTime;
    }    
    
    virtual ~gunCycleClass(){
    }
}; 


//------------------------------------------------------------------------

#define GHOST_SLOW_DOWN 4
int activeGhosts = 0;
class ghostClass: public bouncerClass{
private:
    bool isAlive = true;
    int skippedFrames = 0;
public:
    ghostClass( int nameParam, int xStart, int yStart, int angleStart, const byte* spriteMapParam,
            unsigned long timeToLiveParam, unsigned long targetSpeedParam )
        :bouncerClass(  nameParam,  xStart,  yStart,  angleStart, spriteMapParam, timeToLiveParam, targetSpeedParam ){ }

    void virtual run(){
        
        // slow down, skip frames
        skippedFrames++;
        if( skippedFrames < GHOST_SLOW_DOWN ){
            paint();
            return;
        }else{
            skippedFrames = 0;
        }
        
        bouncerClass::run();
    }
        
    int virtual type(){
        return GHOST_TYPE;
    };        
        
    bool virtual isDone(){
        
        if( !isAlive ) return true;
        
        bool itIsDone = ( millis() > ( birthTime + timeToLive ) );
        if( itIsDone ){
            activeGhosts--;
            isAlive = false;
        }
        return( itIsDone );
    }
    
    void kill(){        
        sound.tone(300, 500);  
        isAlive = false;
        activeGhosts--;
    }
};

//--------------------------------------------------------------------------------------

// start position
#define STARTX 64;
#define STARTY 56;
#define ANGLE_CHANGE_SPEED 4;
#define SIZE_GUN 4
#define GUN_CYCLE_DELAY 200
class playerClass:public eventClass{
public: 
        
    //uses
    int playerName;
    
    //has -  defaulted
    int playerX = STARTX; 
    int playerY = STARTY;
    int aimAngle = 90;
    int realAimlAngle = 0;
    int aimX = 0;              
    int aimY = 0;    
public:         
        
    playerClass( int nameParam ):eventClass(){
        
        playerName = nameParam;
        
    }    
    
    void drawAimer(){
             
        int aimBaseX = playerX + 5;  // middle
        int aimBasey = playerY ;  // gap on top     
        
        if( arduboy.pressed(DOWN_BUTTON) && (aimAngle > 0) ) {
            aimAngle = aimAngle - ANGLE_CHANGE_SPEED;                    
        }

        if( arduboy.pressed(UP_BUTTON ) && (aimAngle < 180) ) {
            aimAngle = aimAngle + ANGLE_CHANGE_SPEED;                                
        }    
          
        // figure angle
        realAimlAngle = 180 - aimAngle;    
        
        // get angle in radians          
        float angleRadians = realAimlAngle * radiansPerAngle;     
        
        // x component
        aimX = roundf( aimBaseX + (SIZE_GUN * cos(angleRadians)));               
        aimY = roundf( aimBasey - (SIZE_GUN * sin(angleRadians)));        
        
        arduboy.drawLine( aimBaseX, aimBasey, aimX, aimY );
        
    }
    
    void drawPlayer(){
        
        if( arduboy.pressed(LEFT_BUTTON) ) {
            playerX--;
            if(playerX < 0){
                playerX = (WIDTH -8);
            }
        }

        if( arduboy.pressed(RIGHT_BUTTON )  ) {
            playerX++;   
            if(playerX > (WIDTH -8)){
                playerX = 0;
            }
        }        
        
        // draw player
        sprites.drawOverwrite( playerX, playerY, playerSprite, 0); 
        
        // shoot!! event
        if( arduboy.pressed(B_BUTTON) && (!gunCycling) && (freeMemory() > 100) ){
                
            sound.tone(700, 100);            
            
            pk++;
            bulletClass* bullet =  new bulletClass( pk, getRealAimX(), getRealAimY(), getRealAimlAngle() );    
            scheduler.Append( bullet );  
            
            gunCycleClass* cycleDelay = new gunCycleClass( pk, GUN_CYCLE_DELAY );
            scheduler.Append( cycleDelay );  
        }           
    }    
    
    int virtual name(){
        return playerName;
    };
    void virtual run(){

        drawPlayer();    
        drawAimer();
               
    }    
    bool virtual isDone(){
        return false;
    }
    unsigned long virtual dueTime(){
        return 0;
    }
    int virtual type(){
        return PLAYER_TYPE;
    };        
    
    
    int getRealAimlAngle(){
        return realAimlAngle;
    }
    int getRealAimX(){
        return aimX;
    }
    int getRealAimY(){
        return aimY;
    }
        
    virtual ~playerClass(){                                
    }
    
};

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

int playerScore = 0;
playerClass* player1 = NULL;
void setup() {
 
    Serial.begin(9600);    
    arduboy.begin();
    arduboy.setFrameRate(50);
        
    // start a player
    pk++;
    player1 = new playerClass(pk);
    scheduler.Append( player1 );                      
}

//-------------------

bool spashScreen = true;

void loop() {
    
    // misc    
    if (!(arduboy.nextFrame())) return;    
    
    // setup
    arduboy.clear();   
    
    if( spashScreen ){
        showSplash();
    };
    
    sprites.drawOverwrite( 0, 0, background,0);        
    arduboy.setCursor( 110, 0 );           
    arduboy.print( playerScore );   
    debug();            
    
    // execute timeline    
    if( scheduler.moveToStart())
        while( true ){                  
            
            eventClass* currentEvent = scheduler.getCurrent();
            
            // run it
            if( !currentEvent->isDone() && ( millis() > currentEvent->dueTime() ) ){   
                currentEvent->run();
            }

            // expired ?
            if( currentEvent->isDone() ){
                if(!scheduler.hasNext()){
                    scheduler.Delete(currentEvent);
                    delete currentEvent;
                    break;
                }else{
                    scheduler.Delete(currentEvent);
                    delete currentEvent;
                    continue;
                }
            }
                
            // next
            if( scheduler.hasNext() ){
                scheduler.next();
            }else{
                break;
            }
            
        }                    
    

    doGohsts();    
    doCollisions();    
    arduboy.display();    
}


void doGohsts(){
    
    int totalGhostsForLevel = 1;    
    if( playerScore > 5 ){        
        totalGhostsForLevel = ( playerScore / 5 ) + 1;
    }
            
    if( (activeGhosts < totalGhostsForLevel) && (freeMemory() > 100) ){
        
        activeGhosts++;

        // make a ghost        
        int randomX = random( 10, 120);
        int randomY = random( 10, 20);
        int randomAngle  = random( 0, 360);
        
        pk++;
        ghostClass* gohst = new ghostClass( pk, randomX, randomY, randomAngle, ghostSprite, 5000, 3 ); // ttl, speed
        scheduler.Append( gohst );                      
    }    
}

void doCollisions(){

    // temp
    LinkedList< eventClass* > tempList;    
    if( scheduler.moveToStart()) while( true ){                              
        tempList.Append( scheduler.getCurrent() );
        if( scheduler.hasNext() ){
            scheduler.next();
        }else{
            break;
        }            
    }

    // check bullets
    if( tempList.moveToStart()) while( true ){                  
                           
        // bullets to ghost and player
        eventClass* Current = tempList.getCurrent();        
        
        if( Current->type() == BULLET_TYPE ){                        
            Point bulletPoint = Point( ((bulletClass*)Current)->currentX, ((bulletClass*)Current)->currentY );
            
            if( scheduler.moveToStart()) while( true ){                              
                eventClass* target = scheduler.getCurrent();
                
                // hit ??
                if(target->type() == GHOST_TYPE){                    
                    Rect targetRect = Rect( ((ghostClass*)target)->currentX, ((ghostClass*)target)->currentY,8,8 );                                                           
                    if(arduboy.collide(bulletPoint, targetRect )){
                        ((ghostClass*)target)->kill();
                        ((bulletClass*)Current)->doHit();
                        playerScore++;
                    }
                }

                // hit ??
                if(target->type() == PLAYER_TYPE){                    
                    Rect targetRect = Rect( ((playerClass*)target)->playerX, ((playerClass*)target)->playerY,8,8 );                                                           
                    if(arduboy.collide(bulletPoint, targetRect )){
                        
                        ((bulletClass*)Current)->doHit();                           
                         playerScore =  playerScore - 2;                              
                         sound.tone(5000, 100);                                                                           
                    }
                }
                
                if( scheduler.hasNext() ){
                    scheduler.next();
                }else{
                    break;
                }            
            }         
        } 
                
        if( Current->type() == GHOST_TYPE ){                        
            
            Rect ghostRect = Rect( ((ghostClass*)Current)->currentX, ((ghostClass*)Current)->currentY, 8, 8 );            
            Rect playerRect = Rect( player1->playerX, player1->playerY,8,8 );                                                           
            
            if(arduboy.collide(ghostRect, playerRect )){
                                                  
                // clear 
                while( scheduler.moveToStart() ){
                    delete( scheduler.getCurrent() );
                    scheduler.DeleteCurrent();
                }
                               
                arduboy.clear();
                arduboy.setCursor( 0, 30 );                              
                arduboy.print( "[[ GAME OVER CHATO!]]\n" );
                arduboy.print( "   final score "  );
                arduboy.print( playerScore );                                
                arduboy.print( "\n"  );                
                arduboy.print( "      press [A]"  );    
                
                activeGhosts = 0;
                playerScore = 0;                 
                gunCycling = false;                
                
                arduboy.display();
                sound.tones(song1);  
                
                pk++;
                player1 = new playerClass(pk);
                scheduler.Append( player1 );  
                                
                while(!arduboy.pressed(A_BUTTON)) delay( 100 );
                                                
                spashScreen = true;
                delay( 500 );
                return;
            }
                
        }       
        
        if( tempList.hasNext() ){
            tempList.next();
        }else{
            break;
        }            

    }    
}

bool freeze = false;
void debug(){
 
//    arduboy.setCursor( 0,0 );
//    arduboy.print(freeMemory()); 
}

void showSplash(){
       
    sprites.drawOverwrite( 0, 0, splashScreen,0);
    arduboy.setCursor( 0, 0);
    arduboy.print( "press [A]\n" );    
    arduboy.print( "Up/Dwn aim\n" );          
    
    arduboy.display();
    
    while(!arduboy.pressed(A_BUTTON)){ 
        delay( 100 );
    }       
    spashScreen = false;
}

